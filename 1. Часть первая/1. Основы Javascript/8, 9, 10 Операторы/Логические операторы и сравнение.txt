Строки сравниваются побуквенно
alert( 'Б' > 'А' ); // true
Юникод у символа Б больше, чем у А, поэтому и результат сравнения такой.
В кодировке Unicode обычно код у строчной (мелкой) буквы больше, чем у прописной.
Если строка состоит из нескольких букв, то сравнение осуществляется как в телефонной книжке или в словаре.
Сначала сравниваются первые буквы, потом вторые, и так далее, пока одна не будет больше другой.
alert( "2" > "14" ); // true, неверно, ведь 2 не больше 14
----------------------Сравнение разных типов--------------------
При сравнении значений разных типов, используется числовое преобразование.
Оно применяется к обоим значениям.
Пустая строка, как и false, при преобразовании к числу дают 0.
alert( 0 == false ); // true

При сравнении значений разных типов, используется числовое преобразование.
При преобразовании в число null становится 0, а undefined становится NaN.
Но при этом значения null и undefined равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
Для undefined это сходится
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
А вот для null нет
alert( null > 0 ); // false
alert( null == 0 ); // false
alert(null >= 0); // true
Дело в том, что алгоритмы проверки равенства == и сравнения >= > < <= работают по-разному.
В сравнениях (с участием >,<) их лучше не использовать, так как они ведут себя не как 0.

